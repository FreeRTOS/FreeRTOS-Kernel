/*
 * FreeRTOS Kernel <DEVELOPMENT BRANCH>
 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * https://www.FreeRTOS.org
 * https://github.com/FreeRTOS
 *
 */

/*
 * This is the old_list implementation used by the scheduler.  While it is tailored
 * heavily for the schedulers needs, it is also available for use by
 * application code.
 *
 * old_list_ts can only store pointers to old_list_item_ts.  Each old_ListItem_t contains a
 * numeric value (xItemValue).  Most of the time the old_lists are sorted in
 * ascending item value order.
 *
 * old_Lists are created already containing one old_list item.  The value of this
 * item is the maximum possible that can be stored, it is therefore always at
 * the end of the old_list and acts as a marker.  The old_list member pxHead always
 * points to this marker - even though it is at the tail of the old_list.  This
 * is because the tail contains a wrap back pointer to the true head of
 * the old_list.
 *
 * In addition to it's value, each old_list item contains a pointer to the next
 * item in the old_list (pxNext), a pointer to the old_list it is in (pxContainer)
 * and a pointer to back to the object that contains it.  These later two
 * pointers are included for efficiency of old_list manipulation.  There is
 * effectively a two way link between the object containing the old_list item and
 * the old_list item itself.
 *
 *
 * \page old_ListIntroduction old_List Implementation
 * \ingroup FreeRTOSIntro
 */


#ifndef old_LIST_H
#define old_LIST_H

#ifndef INC_FREERTOS_H
    #error "FreeRTOS.h must be included before old_list.h"
#endif

/*
 * The old_list structure members are modified from within interrupts, and therefore
 * by rights should be declared volatile.  However, they are only modified in a
 * functionally atomic way (within critical sections of with the scheduler
 * suspended) and are either passed by reference into a function or indexed via
 * a volatile variable.  Therefore, in all use cases tested so far, the volatile
 * qualifier can be omitted in order to provide a moderate performance
 * improvement without adversely affecting functional behaviour.  The assembly
 * instructions generated by the IAR, ARM and GCC compilers when the respective
 * compiler's options were set for maximum optimisation has been inspected and
 * deemed to be as intended.  That said, as compiler technology advances, and
 * especially if aggressive cross module optimisation is used (a use case that
 * has not been exercised to any great extend) then it is feasible that the
 * volatile qualifier will be needed for correct optimisation.  It is expected
 * that a compiler removing essential code because, without the volatile
 * qualifier on the old_list structure members and with aggressive cross module
 * optimisation, the compiler deemed the code unnecessary will result in
 * complete and obvious failure of the scheduler.  If this is ever experienced
 * then the volatile qualifier can be inserted in the relevant places within the
 * old_list structures by simply defining configold_LIST_VOLATILE to volatile in
 * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
 * If configold_LIST_VOLATILE is not defined then the preprocessor directives below
 * will simply #define configold_LIST_VOLATILE away completely.
 *
 * To use volatile old_list structure members then add the following line to
 * FreeRTOSConfig.h (without the quotes):
 * "#define configold_LIST_VOLATILE volatile"
 */
#ifndef configold_LIST_VOLATILE
    #define configold_LIST_VOLATILE
#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */

/* *INDENT-OFF* */
#ifdef __cplusplus
    extern "C" {
#endif
/* *INDENT-ON* */

/* Macros that can be used to place known values within the old_list structures,
 * then check that the known values do not get corrupted during the execution of
 * the application.   These may catch the old_list data structures being overwritten in
 * memory.  They will not catch data errors caused by incorrect configuration or
 * use of FreeRTOS.*/
#if ( configUSE_old_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
    /* Define the macros to do nothing. */
    #define old_listFIRST_old_LIST_ITEM_INTEGRITY_CHECK_VALUE
    #define old_listSECOND_old_LIST_ITEM_INTEGRITY_CHECK_VALUE
    #define old_listFIRST_old_LIST_INTEGRITY_CHECK_VALUE
    #define old_listSECOND_old_LIST_INTEGRITY_CHECK_VALUE
    #define old_listSET_FIRST_old_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
    #define old_listSET_SECOND_old_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
    #define old_listSET_old_LIST_INTEGRITY_CHECK_1_VALUE( pxold_List )
    #define old_listSET_old_LIST_INTEGRITY_CHECK_2_VALUE( pxold_List )
    #define old_listTEST_old_LIST_ITEM_INTEGRITY( pxItem )
    #define old_listTEST_old_LIST_INTEGRITY( pxold_List )
#else /* if ( configUSE_old_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 ) */
    /* Define macros that add new members into the old_list structures. */
    #define old_listFIRST_old_LIST_ITEM_INTEGRITY_CHECK_VALUE     TickType_t xold_ListItemIntegrityValue1;
    #define old_listSECOND_old_LIST_ITEM_INTEGRITY_CHECK_VALUE    TickType_t xold_ListItemIntegrityValue2;
    #define old_listFIRST_old_LIST_INTEGRITY_CHECK_VALUE          TickType_t xold_ListIntegrityValue1;
    #define old_listSECOND_old_LIST_INTEGRITY_CHECK_VALUE         TickType_t xold_ListIntegrityValue2;

/* Define macros that set the new structure members to known values. */
    #define old_listSET_FIRST_old_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )     ( pxItem )->xold_ListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
    #define old_listSET_SECOND_old_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )    ( pxItem )->xold_ListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
    #define old_listSET_old_LIST_INTEGRITY_CHECK_1_VALUE( pxold_List )              ( pxold_List )->xold_ListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
    #define old_listSET_old_LIST_INTEGRITY_CHECK_2_VALUE( pxold_List )              ( pxold_List )->xold_ListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE

/* Define macros that will assert if one of the structure members does not
 * contain its expected value. */
    #define old_listTEST_old_LIST_ITEM_INTEGRITY( pxItem )                      configASSERT( ( ( pxItem )->xold_ListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xold_ListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
    #define old_listTEST_old_LIST_INTEGRITY( pxold_List )                           configASSERT( ( ( pxold_List )->xold_ListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxold_List )->xold_ListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
#endif /* configUSE_old_LIST_DATA_INTEGRITY_CHECK_BYTES */


/*
 * Definition of the only type of object that a old_list can contain.
 */
struct xold_LIST;
struct xold_LIST_ITEM
{
    old_listFIRST_old_LIST_ITEM_INTEGRITY_CHECK_VALUE           /*< Set to a known value if configUSE_old_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    configold_LIST_VOLATILE TickType_t xItemValue;          /*< The value being old_listed.  In most cases this is used to sort the old_list in ascending order. */
    struct xold_LIST_ITEM * configold_LIST_VOLATILE pxNext;     /*< Pointer to the next old_ListItem_t in the old_list. */
    struct xold_LIST_ITEM * configold_LIST_VOLATILE pxPrevious; /*< Pointer to the previous old_ListItem_t in the old_list. */
    void * pvOwner;                                     /*< Pointer to the object (normally a TCB) that contains the old_list item.  There is therefore a two way link between the object containing the old_list item and the old_list item itself. */
    struct xold_LIST * configold_LIST_VOLATILE pxContainer;     /*< Pointer to the old_list in which this old_list item is placed (if any). */
    old_listSECOND_old_LIST_ITEM_INTEGRITY_CHECK_VALUE          /*< Set to a known value if configUSE_old_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
};
typedef struct xold_LIST_ITEM old_ListItem_t;                   /* For some reason lint wants this as two separate definitions. */

#if ( configUSE_MINI_old_LIST_ITEM == 1 )
    struct xMINI_old_LIST_ITEM
    {
        old_listFIRST_old_LIST_ITEM_INTEGRITY_CHECK_VALUE /*< Set to a known value if configUSE_old_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
        configold_LIST_VOLATILE TickType_t xItemValue;
        struct xold_LIST_ITEM * configold_LIST_VOLATILE pxNext;
        struct xold_LIST_ITEM * configold_LIST_VOLATILE pxPrevious;
    };
    typedef struct xMINI_old_LIST_ITEM Miniold_ListItem_t;
#else
    typedef struct xold_LIST_ITEM      Miniold_ListItem_t;
#endif

/*
 * Definition of the type of queue used by the scheduler.
 */
typedef struct xold_LIST
{
    old_listFIRST_old_LIST_INTEGRITY_CHECK_VALUE      /*< Set to a known value if configUSE_old_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    volatile UBaseType_t uxNumberOfItems;
    old_ListItem_t * configold_LIST_VOLATILE pxIndex; /*< Used to walk through the old_list.  Points to the last item returned by a call to old_listGET_OWNER_OF_NEXT_ENTRY (). */
    old_ListItem_t xold_ListEnd;                  /*< old_List item that contains the maximum possible item value meaning it is always at the end of the old_list and is therefore used as a marker. */
    old_listSECOND_old_LIST_INTEGRITY_CHECK_VALUE     /*< Set to a known value if configUSE_old_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
} old_List_t;

/*
 * Access macro to set the owner of a old_list item.  The owner of a old_list item
 * is the object (usually a TCB) that contains the old_list item.
 *
 * \page old_listSET_old_LIST_ITEM_OWNER old_listSET_old_LIST_ITEM_OWNER
 * \ingroup Linkedold_List
 */
#define old_listSET_old_LIST_ITEM_OWNER( pxold_ListItem, pxOwner )    ( ( pxold_ListItem )->pvOwner = ( void * ) ( pxOwner ) )

/*
 * Access macro to get the owner of a old_list item.  The owner of a old_list item
 * is the object (usually a TCB) that contains the old_list item.
 *
 * \page old_listGET_old_LIST_ITEM_OWNER old_listSET_old_LIST_ITEM_OWNER
 * \ingroup Linkedold_List
 */
#define old_listGET_old_LIST_ITEM_OWNER( pxold_ListItem )             ( ( pxold_ListItem )->pvOwner )

/*
 * Access macro to set the value of the old_list item.  In most cases the value is
 * used to sort the old_list in ascending order.
 *
 * \page old_listSET_old_LIST_ITEM_VALUE old_listSET_old_LIST_ITEM_VALUE
 * \ingroup Linkedold_List
 */
#define old_listSET_old_LIST_ITEM_VALUE( pxold_ListItem, xValue )     ( ( pxold_ListItem )->xItemValue = ( xValue ) )

/*
 * Access macro to retrieve the value of the old_list item.  The value can
 * represent anything - for example the priority of a task, or the time at
 * which a task should be unblocked.
 *
 * \page old_listGET_old_LIST_ITEM_VALUE old_listGET_old_LIST_ITEM_VALUE
 * \ingroup Linkedold_List
 */
#define old_listGET_old_LIST_ITEM_VALUE( pxold_ListItem )             ( ( pxold_ListItem )->xItemValue )

/*
 * Access macro to retrieve the value of the old_list item at the head of a given
 * old_list.
 *
 * \page old_listGET_old_LIST_ITEM_VALUE old_listGET_old_LIST_ITEM_VALUE
 * \ingroup Linkedold_List
 */
#define old_listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxold_List )        ( ( ( pxold_List )->xold_ListEnd ).pxNext->xItemValue )

/*
 * Return the old_list item at the head of the old_list.
 *
 * \page old_listGET_HEAD_ENTRY old_listGET_HEAD_ENTRY
 * \ingroup Linkedold_List
 */
#define old_listGET_HEAD_ENTRY( pxold_List )                      ( ( ( pxold_List )->xold_ListEnd ).pxNext )

/*
 * Return the next old_list item.
 *
 * \page old_listGET_NEXT old_listGET_NEXT
 * \ingroup Linkedold_List
 */
#define old_listGET_NEXT( pxold_ListItem )                        ( ( pxold_ListItem )->pxNext )

/*
 * Return the old_list item that marks the end of the old_list
 *
 * \page old_listGET_END_MARKER old_listGET_END_MARKER
 * \ingroup Linkedold_List
 */
#define old_listGET_END_MARKER( pxold_List )                      ( ( old_ListItem_t const * ) ( &( ( pxold_List )->xold_ListEnd ) ) )

/*
 * Access macro to determine if a old_list contains any items.  The macro will
 * only have the value true if the old_list is empty.
 *
 * \page old_listold_LIST_IS_EMPTY old_listold_LIST_IS_EMPTY
 * \ingroup Linkedold_List
 */
#define old_listold_LIST_IS_EMPTY( pxold_List )                       ( ( ( pxold_List )->uxNumberOfItems == ( UBaseType_t ) 0 ) ? pdTRUE : pdFALSE )

/*
 * Access macro to return the number of items in the old_list.
 */
#define old_listCURRENT_old_LIST_LENGTH( pxold_List )                 ( ( pxold_List )->uxNumberOfItems )

/*
 * Access function to obtain the owner of the next entry in a old_list.
 *
 * The old_list member pxIndex is used to walk through a old_list.  Calling
 * old_listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the old_list
 * and returns that entry's pxOwner parameter.  Using multiple calls to this
 * function it is therefore possible to move through every item contained in
 * a old_list.
 *
 * The pxOwner parameter of a old_list item is a pointer to the object that owns
 * the old_list item.  In the scheduler this is normally a task control block.
 * The pxOwner parameter effectively creates a two way link between the old_list
 * item and its owner.
 *
 * @param pxTCB pxTCB is set to the address of the owner of the next old_list item.
 * @param pxold_List The old_list from which the next item owner is to be returned.
 *
 * \page old_listGET_OWNER_OF_NEXT_ENTRY old_listGET_OWNER_OF_NEXT_ENTRY
 * \ingroup Linkedold_List
 */
#define old_listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxold_List )                                           \
    {                                                                                          \
        old_List_t * const pxConstold_List = ( pxold_List );                                               \
        /* Increment the index to the next item and return the item, ensuring */               \
        /* we don't return the marker used at the end of the old_list.  */                         \
        ( pxConstold_List )->pxIndex = ( pxConstold_List )->pxIndex->pxNext;                           \
        if( ( void * ) ( pxConstold_List )->pxIndex == ( void * ) &( ( pxConstold_List )->xold_ListEnd ) ) \
        {                                                                                      \
            ( pxConstold_List )->pxIndex = ( pxConstold_List )->pxIndex->pxNext;                       \
        }                                                                                      \
        ( pxTCB ) = ( pxConstold_List )->pxIndex->pvOwner;                                         \
    }

/*
 * Version of uxold_ListRemove() that does not return a value.  Provided as a slight
 * optimisation for xTaskIncrementTick() by being inline.
 *
 * Remove an item from a old_list.  The old_list item has a pointer to the old_list that
 * it is in, so only the old_list item need be passed into the function.
 *
 * @param uxold_ListRemove The item to be removed.  The item will remove itself from
 * the old_list pointed to by it's pxContainer parameter.
 *
 * @return The number of items that remain in the old_list after the old_list item has
 * been removed.
 *
 * \page old_listREMOVE_ITEM old_listREMOVE_ITEM
 * \ingroup Linkedold_List
 */
#define old_listREMOVE_ITEM( pxItemToRemove ) \
    {                                     \
        /* The old_list item knows which old_list it is in.  Obtain the old_list from the old_list \
         * item. */                                                              \
        old_List_t * const pxold_List = ( pxItemToRemove )->pxContainer;                 \
                                                                                 \
        ( pxItemToRemove )->pxNext->pxPrevious = ( pxItemToRemove )->pxPrevious; \
        ( pxItemToRemove )->pxPrevious->pxNext = ( pxItemToRemove )->pxNext;     \
        /* Make sure the index is left pointing to a valid item. */              \
        if( pxold_List->pxIndex == ( pxItemToRemove ) )                              \
        {                                                                        \
            pxold_List->pxIndex = ( pxItemToRemove )->pxPrevious;                    \
        }                                                                        \
                                                                                 \
        ( pxItemToRemove )->pxContainer = NULL;                                  \
        ( pxold_List->uxNumberOfItems )--;                                           \
    }

/*
 * Inline version of vold_ListInsertEnd() to provide slight optimisation for
 * xTaskIncrementTick().
 *
 * Insert a old_list item into a old_list.  The item will be inserted in a position
 * such that it will be the last item within the old_list returned by multiple
 * calls to old_listGET_OWNER_OF_NEXT_ENTRY.
 *
 * The old_list member pxIndex is used to walk through a old_list.  Calling
 * old_listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the old_list.
 * Placing an item in a old_list using vold_ListInsertEnd effectively places the item
 * in the old_list position pointed to by pxIndex.  This means that every other
 * item within the old_list will be returned by old_listGET_OWNER_OF_NEXT_ENTRY before
 * the pxIndex parameter again points to the item being inserted.
 *
 * @param pxold_List The old_list into which the item is to be inserted.
 *
 * @param pxNewold_ListItem The old_list item to be inserted into the old_list.
 *
 * \page old_listINSERT_END old_listINSERT_END
 * \ingroup Linkedold_List
 */
#define old_listINSERT_END( pxold_List, pxNewold_ListItem )           \
    {                                                     \
        old_ListItem_t * const pxIndex = ( pxold_List )->pxIndex; \
                                                          \
        /* Only effective when configASSERT() is also defined, these tests may catch \
         * the old_list data structures being overwritten in memory.  They will not catch \
         * data errors caused by incorrect configuration or use of FreeRTOS. */ \
        old_listTEST_old_LIST_INTEGRITY( ( pxold_List ) );                                  \
        old_listTEST_old_LIST_ITEM_INTEGRITY( ( pxNewold_ListItem ) );                      \
                                                                                \
        /* Insert a new old_list item into ( pxold_List ), but rather than sort the old_list, \
         * makes the new old_list item the last item to be removed by a call to \
         * old_listGET_OWNER_OF_NEXT_ENTRY(). */                 \
        ( pxNewold_ListItem )->pxNext = pxIndex;                 \
        ( pxNewold_ListItem )->pxPrevious = pxIndex->pxPrevious; \
                                                             \
        pxIndex->pxPrevious->pxNext = ( pxNewold_ListItem );     \
        pxIndex->pxPrevious = ( pxNewold_ListItem );             \
                                                             \
        /* Remember which old_list the item is in. */            \
        ( pxNewold_ListItem )->pxContainer = ( pxold_List );         \
                                                             \
        ( ( pxold_List )->uxNumberOfItems )++;                   \
    }

/*
 * Access function to obtain the owner of the first entry in a old_list.  old_Lists
 * are normally sorted in ascending item value order.
 *
 * This function returns the pxOwner member of the first item in the old_list.
 * The pxOwner parameter of a old_list item is a pointer to the object that owns
 * the old_list item.  In the scheduler this is normally a task control block.
 * The pxOwner parameter effectively creates a two way link between the old_list
 * item and its owner.
 *
 * @param pxold_List The old_list from which the owner of the head item is to be
 * returned.
 *
 * \page old_listGET_OWNER_OF_HEAD_ENTRY old_listGET_OWNER_OF_HEAD_ENTRY
 * \ingroup Linkedold_List
 */
#define old_listGET_OWNER_OF_HEAD_ENTRY( pxold_List )            ( ( &( ( pxold_List )->xold_ListEnd ) )->pxNext->pvOwner )

/*
 * Check to see if a old_list item is within a old_list.  The old_list item maintains a
 * "container" pointer that points to the old_list it is in.  All this macro does
 * is check to see if the container and the old_list match.
 *
 * @param pxold_List The old_list we want to know if the old_list item is within.
 * @param pxold_ListItem The old_list item we want to know if is in the old_list.
 * @return pdTRUE if the old_list item is in the old_list, otherwise pdFALSE.
 */
#define old_listIS_CONTAINED_WITHIN( pxold_List, pxold_ListItem )    ( ( ( pxold_ListItem )->pxContainer == ( pxold_List ) ) ? ( pdTRUE ) : ( pdFALSE ) )

/*
 * Return the old_list a old_list item is contained within (referenced from).
 *
 * @param pxold_ListItem The old_list item being queried.
 * @return A pointer to the old_List_t object that references the pxold_ListItem
 */
#define old_listold_LIST_ITEM_CONTAINER( pxold_ListItem )            ( ( pxold_ListItem )->pxContainer )

/*
 * This provides a crude means of knowing if a old_list has been initialised, as
 * pxold_List->xold_ListEnd.xItemValue is set to portMAX_DELAY by the vold_ListInitialise()
 * function.
 */
#define old_listold_LIST_IS_INITIALISED( pxold_List )                ( ( pxold_List )->xold_ListEnd.xItemValue == portMAX_DELAY )

/*
 * Must be called before a old_list is used!  This initialises all the members
 * of the old_list structure and inserts the xold_ListEnd item into the old_list as a
 * marker to the back of the old_list.
 *
 * @param pxold_List Pointer to the old_list being initialised.
 *
 * \page vold_ListInitialise vold_ListInitialise
 * \ingroup Linkedold_List
 */
void vold_ListInitialise( old_List_t * const pxold_List ) PRIVILEGED_FUNCTION;

/*
 * Must be called before a old_list item is used.  This sets the old_list container to
 * null so the item does not think that it is already contained in a old_list.
 *
 * @param pxItem Pointer to the old_list item being initialised.
 *
 * \page vold_ListInitialiseItem vold_ListInitialiseItem
 * \ingroup Linkedold_List
 */
void vold_ListInitialiseItem( old_ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;

/*
 * Insert a old_list item into a old_list.  The item will be inserted into the old_list in
 * a position determined by its item value (ascending item value order).
 *
 * @param pxold_List The old_list into which the item is to be inserted.
 *
 * @param pxNewold_ListItem The item that is to be placed in the old_list.
 *
 * \page vold_ListInsert vold_ListInsert
 * \ingroup Linkedold_List
 */
void vold_ListInsert( old_List_t * const pxold_List,
                  old_ListItem_t * const pxNewold_ListItem ) PRIVILEGED_FUNCTION;

/*
 * Insert a old_list item into a old_list.  The item will be inserted in a position
 * such that it will be the last item within the old_list returned by multiple
 * calls to old_listGET_OWNER_OF_NEXT_ENTRY.
 *
 * The old_list member pxIndex is used to walk through a old_list.  Calling
 * old_listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the old_list.
 * Placing an item in a old_list using vold_ListInsertEnd effectively places the item
 * in the old_list position pointed to by pxIndex.  This means that every other
 * item within the old_list will be returned by old_listGET_OWNER_OF_NEXT_ENTRY before
 * the pxIndex parameter again points to the item being inserted.
 *
 * @param pxold_List The old_list into which the item is to be inserted.
 *
 * @param pxNewold_ListItem The old_list item to be inserted into the old_list.
 *
 * \page vold_ListInsertEnd vold_ListInsertEnd
 * \ingroup Linkedold_List
 */
void vold_ListInsertEnd( old_List_t * const pxold_List,
                     old_ListItem_t * const pxNewold_ListItem ) PRIVILEGED_FUNCTION;

/*
 * Remove an item from a old_list.  The old_list item has a pointer to the old_list that
 * it is in, so only the old_list item need be passed into the function.
 *
 * @param uxold_ListRemove The item to be removed.  The item will remove itself from
 * the old_list pointed to by it's pxContainer parameter.
 *
 * @return The number of items that remain in the old_list after the old_list item has
 * been removed.
 *
 * \page uxold_ListRemove uxold_ListRemove
 * \ingroup Linkedold_List
 */
UBaseType_t uxold_ListRemove( old_ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;

/* *INDENT-OFF* */
#ifdef __cplusplus
    }
#endif
/* *INDENT-ON* */

#endif /* ifndef old_LIST_H */
